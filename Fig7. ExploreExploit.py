import os
import sys
import inspect
import numpy as np
import sklearn.model_selection
import sklearn.svm
import matplotlib.pyplot as plt
import matplotlib
import time
import Details as D
import ImportData
import Plot
import Maths

# Configuration
N_SPLITS = 5
N_REPEATS = 1
N_SAMPLES = 20
RESOLUTION = 1  # Take every nth time point


class NeuralDecoder:
    """Handles neural decoding analysis for explore/exploit conditions."""

    def __init__(self, n_splits=N_SPLITS, n_repeats=N_REPEATS):
        self.decoder = sklearn.svm.LinearSVC(max_iter=25000)
        self.n_splits = n_splits
        self.n_repeats = n_repeats

    def prepare_data(self, data, task_variable, resolution=RESOLUTION):
        """
        Prepare neural and behavioral data for decoding.

        Args:
            data: ImportData object containing neural recordings
            task_variable: String indicating which behavioral variable to decode ('c1dir' or 'c1chosen')
            resolution: Temporal resolution (take every nth time point)

        Returns:
            neural_data_all: List of neural responses per cell
            labels_all: List of behavioral labels per cell
            high_reward_masks: List of boolean masks for high reward trials
            low_reward_masks: List of boolean masks for low/medium reward trials
            min_trials: Minimum number of trials per condition
        """
        min_trials = 10000
        neural_data_all = []
        labels_all = []
        high_reward_masks = []
        low_reward_masks = []

        for cell_idx in range(data.n):
            trial_data = data.behavdata[cell_idx]

            # Define high reward (2 consecutive high rewards) and low reward conditions
            high_reward_mask = (trial_data.previousreward == 2) & (trial_data.previouspreviousreward == 2)
            low_reward_mask = (trial_data.previousreward != 2) & (trial_data.previouspreviousreward != 2)

            # Get neural responses and task labels
            neural_response = data.generate_epoch_norm(cell_idx, D.sc_choice1made)
            neural_response = neural_response[:, ::resolution]

            if task_variable == 'c1dir':
                labels = trial_data.c1dir
            elif task_variable == 'c1chosen':
                labels = trial_data.c1chosen
            else:
                raise ValueError(f"Unknown task variable: {task_variable}")

            # Calculate minimum trials per condition
            high_min = min([np.sum(labels[high_reward_mask] == label)
                            for label in np.unique(labels)])
            low_min = min([np.sum(labels[low_reward_mask] == label)
                           for label in np.unique(labels)])
            cell_min_trials = min(high_min, low_min)

            if cell_min_trials < min_trials:
                min_trials = cell_min_trials

            neural_data_all.append(neural_response)
            labels_all.append(labels)
            high_reward_masks.append(high_reward_mask)
            low_reward_masks.append(low_reward_mask)

        return neural_data_all, labels_all, high_reward_masks, low_reward_masks, min_trials

    def run_cross_validated_decoding(self, data, neural_data_all, labels_all,
                                     high_reward_masks, low_reward_masks,
                                     min_trials, n_samples=N_SAMPLES):
        """
        Run cross-validated decoding for multiple random samples.

        Args:
            data: ImportData object
            neural_data_all: List of neural responses
            labels_all: List of behavioral labels
            high_reward_masks: List of high reward trial masks
            low_reward_masks: List of low reward trial masks
            min_trials: Minimum trials to use per condition
            n_samples: Number of random samples to run

        Returns:
            high_reward_accuracy: Accuracy for high reward (exploit) trials
            low_reward_accuracy: Accuracy for low reward (explore) trials
        """
        n_timepoints = data.numTimepoints // RESOLUTION
        n_unique_labels = len(np.unique(labels_all[0]))

        high_reward_accuracy = np.empty((n_timepoints, n_samples))
        low_reward_accuracy = np.empty((n_timepoints, n_samples))

        for sample_idx in range(n_samples):
            cv_splitter = sklearn.model_selection.RepeatedStratifiedKFold(
                n_splits=self.n_splits,
                n_repeats=self.n_repeats,
                random_state=sample_idx
            )

            print(f'  Sample {sample_idx + 1}/{n_samples}')

            # Prepare population data
            high_reward_pop = np.empty((data.n, n_unique_labels, min_trials, n_timepoints))
            low_reward_pop = np.empty((data.n, n_unique_labels, min_trials, n_timepoints))
            label_array = np.empty((data.n, n_unique_labels, min_trials))

            for cell_idx in range(data.n):
                high_mask = high_reward_masks[cell_idx]
                low_mask = low_reward_masks[cell_idx]

                for condition_mask, population_array in [(high_mask, high_reward_pop),
                                                         (low_mask, low_reward_pop)]:
                    neural_response = neural_data_all[cell_idx][condition_mask]
                    labels = labels_all[cell_idx][condition_mask]

                    for label_idx, label_value in enumerate(np.unique(labels)):
                        # Randomly sample trials for this label
                        matching_trials = neural_response[labels == label_value]
                        random_indices = np.random.permutation(len(matching_trials))[:min_trials]

                        population_array[cell_idx, label_idx] = matching_trials[random_indices]
                        label_array[cell_idx, label_idx] = label_idx

            # Reshape for decoding
            labels_flat = label_array.reshape(data.n, -1)[0, :]
            high_reward_pop = high_reward_pop.reshape(data.n, -1, n_timepoints)
            low_reward_pop = low_reward_pop.reshape(data.n, -1, n_timepoints)

            # Decode at each timepoint
            for time_idx in range(n_timepoints):
                high_features = high_reward_pop[..., time_idx].T
                low_features = low_reward_pop[..., time_idx].T

                high_scores = sklearn.model_selection.cross_val_score(
                    self.decoder, high_features, labels_flat,
                    cv=cv_splitter, n_jobs=D.n_cores
                )
                low_scores = sklearn.model_selection.cross_val_score(
                    self.decoder, low_features, labels_flat,
                    cv=cv_splitter, n_jobs=D.n_cores
                )

                high_reward_accuracy[time_idx, sample_idx] = np.mean(high_scores)
                low_reward_accuracy[time_idx, sample_idx] = np.mean(low_scores)

        return high_reward_accuracy, low_reward_accuracy


def plot_results(explore_accuracy, exploit_accuracy, data):
    # Plot configuration
    matplotlib.rc('xtick', labelsize=12)
    matplotlib.rc('ytick', labelsize=12)

    fig = plt.figure(figsize=(13.2, 8.8), dpi=200)

    height_ratios = [1, 0.5, 1, 0.2, 1]
    width_ratios = [1, 0.2, 1, 0.3, 1]
    gs = plt.GridSpec(len(height_ratios), len(width_ratios),
                      height_ratios=height_ratios, width_ratios=width_ratios,
                      hspace=0, wspace=0)

    # Create axes
    axes = [None, None, None,
            fig.add_subplot(gs[2, 0]), fig.add_subplot(gs[2, 2]), fig.add_subplot(gs[2, 4]),
            fig.add_subplot(gs[4, 0]), fig.add_subplot(gs[4, 2]), fig.add_subplot(gs[4, 4])]

    # Format axes
    for ax in axes[3:]:
        Plot.set_xlim(data, ax, -600, 600, offset=-600, res=300)
        ax.spines['right'].set_visible(False)
        ax.spines['top'].set_visible(False)
        ax.axvline(60, ls='--', c='k', lw=0.5, zorder=-1)

    for ax in axes[6:]:
        ax.set_xlabel('Time (ms) post choice 1', fontsize=13)

    # Add panel letters
    Plot.let(axes[3], 0, -0.15, 1.15, fontsize=14)
    Plot.let(axes[4], 1, -0.125, 1.15, fontsize=14)
    Plot.let(axes[5], 2, -0.15, 1.15, fontsize=14)
    Plot.let(axes[6], 3, -0.125, fontsize=14)
    Plot.let(axes[7], 4, -0.125, fontsize=14)
    Plot.let(axes[8], 5, -0.15, fontsize=14)

    # Plot data for each brain area
    for area_idx, area_name in enumerate(D.areas[1:]):
        color = f'C{area_idx}'

        # CUE IDENTITY: Explore (Panel A)
        explore_cue = explore_accuracy['cue'][area_idx].T * 100
        avg, sem = Plot.AvgSem(explore_cue, axes[4], label=area_name,
                               showleg=False, c=color, lw=2.5)

        # CUE IDENTITY: Exploit (Panel B)
        exploit_cue = exploit_accuracy['cue'][area_idx].T * 100
        avg_exploit, sem_exploit = Plot.AvgSem(exploit_cue, axes[3], label=area_name,
                                               showleg=False, c=color, lw=2.5)

        # CUE IDENTITY: Difference (Panel C)
        difference_cue = exploit_cue - explore_cue
        avg_diff, sem_diff = Plot.AvgSem(difference_cue, axes[5], label=area_name,
                                         showleg=False, c=color, lw=2.5)

        # DIRECTION: Explore (Panel D)
        explore_dir = explore_accuracy['direction'][area_idx].T * 100
        avg_dir_explore, _ = Plot.AvgSem(explore_dir, axes[7], label=area_name,
                                         showleg=False, c=color, lw=2.5)

        # DIRECTION: Exploit (Panel E)
        exploit_dir = exploit_accuracy['direction'][area_idx].T * 100
        avg_dir_exploit, _ = Plot.AvgSem(exploit_dir, axes[6], label=area_name,
                                         showleg=False, c=color, lw=2.5)

        # DIRECTION: Difference (Panel F)
        difference_dir = exploit_dir - explore_dir
        avg_diff_dir, sem_diff_dir = Plot.AvgSem(difference_dir, axes[8], label=area_name,
                                                 showleg=False, c=color, lw=2.5)

    # Format cue identity panels (top row)
    axes[3].axhline(50, color='gray', zorder=0, lw=0.5)
    axes[4].axhline(50, color='gray', zorder=0, lw=0.5)
    axes[3].set_ylabel('Accuracy (%)', fontsize=13)
    axes[3].set_ylim(40, 100)
    axes[4].set_ylim(40, 100)
    axes[5].set_ylabel('Difference', fontsize=13)
    axes[5].set_ylim(-20, 40)
    axes[5].axhline(0, lw=0.5, c='gray', zorder=-1)

    axes[3].set_title("Exploit (after 2 high rewards)")
    axes[4].set_title("Explore (after 2 low/med. rewards)")
    axes[5].set_title("Explore - Exploit")
    axes[3].text(2, 85, 'Cue\nchosen', fontsize=12,
                 horizontalalignment='left', verticalalignment='center')

    # Format direction panels (bottom row)
    axes[6].axhline(33, color='gray', zorder=0, lw=0.5)
    axes[7].axhline(33, color='gray', zorder=0, lw=0.5)
    axes[6].set_ylabel('Accuracy (%)', fontsize=13)
    axes[6].set_ylim(25, 90)
    axes[7].set_ylim(25, 90)
    axes[8].set_ylabel('Difference', fontsize=13)
    axes[8].set_ylim(-20, 40)
    axes[8].axhline(0, lw=0.5, c='gray', zorder=-1)
    axes[6].text(2, 70, 'Direction\nchosen', fontsize=12,
                 horizontalalignment='left', verticalalignment='center')

    axes[6].legend(loc='lower left', bbox_to_anchor=[0, 1.15], ncol=4)

    plt.show()


def main():
    decoder = NeuralDecoder()

    # Storage for results
    explore_accuracy = {'direction': [], 'cue': []}
    exploit_accuracy = {'direction': [], 'cue': []}

    # Analyze each brain area
    for area_idx, area_name in enumerate(D.areas[1:]):
        print(f"Processing area: {area_name}")

        data = ImportData.EntireArea(area_name, 600, 600, exclude_neurons=False)

        # DIRECTION DECODING
        print("\nDirection decoding:")
        start_time = time.time()
        neural_data, labels, high_masks, low_masks, min_trials = decoder.prepare_data(
            data, 'c1dir', RESOLUTION
        )

        exploit_dir, explore_dir = decoder.run_cross_validated_decoding(
            data, neural_data, labels, high_masks, low_masks, min_trials, N_SAMPLES
        )
        print(f"Completed in {time.time() - start_time:.1f} seconds")

        # CUE IDENTITY DECODING
        print("\nCue identity decoding:")
        start_time = time.time()
        neural_data, labels, high_masks, low_masks, min_trials = decoder.prepare_data(
            data, 'c1chosen', RESOLUTION
        )

        exploit_cue, explore_cue = decoder.run_cross_validated_decoding(
            data, neural_data, labels, high_masks, low_masks, min_trials, N_SAMPLES
        )
        print(f"Completed in {time.time() - start_time:.1f} seconds")

        # Store results
        explore_accuracy['direction'].append(explore_dir)
        exploit_accuracy['direction'].append(exploit_dir)
        explore_accuracy['cue'].append(explore_cue)
        exploit_accuracy['cue'].append(exploit_cue)

    # Convert to arrays
    for key in explore_accuracy:
        explore_accuracy[key] = np.array(explore_accuracy[key])
        exploit_accuracy[key] = np.array(exploit_accuracy[key])

    data = ImportData.EntireArea('ACC', 600, 600, exclude_neurons=False)

    plot_results(explore_accuracy, exploit_accuracy, data)


if __name__ == '__main__':
    main()